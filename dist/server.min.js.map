{"version":3,"sources":["server.js"],"names":["express","require","mongoose","multer","path","dotenv","port","process","env","PORT","app","use","bodyParser","json","destination","req","file","cb","filename","diskStorage","Date","now","storage","connect","MONGODB_URI","useNewUrlParser","useUnifiedTopology","then","upload","log","err","Schema","required","type","String","time","console","default","isPrivate","Boolean","toUser","user","single","res","_req$body","text","message","regeneratorRuntime","async","_context","prev","next","body","concat","awrap","save","status","send","t0","post","error","stop","get","username","messages","_context2","query","find","sent","Message","sort","join","__dirname","listen"],"mappings":"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","file":"server.min.js","sourcesContent":["const express = require('express');\r\nconst mongoose = require('mongoose');\r\nconst bodyParser = require('body-parser');\r\nconst multer = require('multer');\r\nconst dotenv = require('dotenv');\r\nconst path = require('path');\r\n\r\n// Load environment variables from .env file\r\ndotenv.config();\r\n\r\nconst app = express();\r\nconst port = process.env.PORT || 3000;\r\n\r\n// Middleware\r\napp.use(bodyParser.json());\r\n\r\n// Set up file upload (for media files like images/videos)\r\nconst storage = multer.diskStorage({\r\n  destination: (req, file, cb) => {\r\n    cb(null, 'uploads/');\r\n  },\r\n  filename: (req, file, cb) => {\r\n    cb(null, Date.now() + '-' + file.originalname);\r\n  }\r\n});\r\nconst upload = multer({ storage });\r\n\r\n// MongoDB Connection\r\nmongoose.connect(process.env.MONGODB_URI, { useNewUrlParser: true, useUnifiedTopology: true })\r\n  .then(() => console.log('MongoDB connected successfully'))\r\n  .catch((err) => console.log('Error connecting to MongoDB:', err));\r\n\r\n// Define Mongoose Models\r\nconst Message = mongoose.model('Message', new mongoose.Schema({\r\n  user: { type: String, required: true },\r\n  text: { type: String },\r\n  file: { type: String }, // URL to the file\r\n  time: { type: Date, default: Date.now },\r\n  isPrivate: { type: Boolean, default: false },\r\n  toUser: { type: String }, // Private message recipient\r\n}));\r\n\r\n// Route to send a message (public or private)\r\napp.post('/send-message', upload.single('file'), async (req, res) => {\r\n  const { user, text, toUser, isPrivate } = req.body;\r\n  const file = req.file ? `/uploads/${req.file.filename}` : null;\r\n\r\n  // Logging for debugging to make sure the data is being received correctly\r\n  console.log('Received message data:', { user, text, toUser, isPrivate, file });\r\n\r\n  try {\r\n    const message = new Message({\r\n      user,\r\n      text,\r\n      file,\r\n      isPrivate,\r\n      toUser,\r\n    });\r\n\r\n    // Saving the message to the database\r\n    await message.save();\r\n\r\n    // If successful, log the success and send a response\r\n    console.log('Message saved to DB');\r\n    res.status(200).send({ message: 'Message sent successfully!' });\r\n  } catch (error) {\r\n    // If an error occurs, log it and send the error response\r\n    console.log('Error sending message:', error);\r\n    res.status(500).send({ message: 'Error sending message', error });\r\n  }\r\n});\r\n\r\n// Route to get all messages (or filtered messages based on user)\r\napp.get('/messages', async (req, res) => {\r\n  const { username } = req.query; // We can pass the `username` as a query parameter to filter messages\r\n\r\n  try {\r\n    let messages;\r\n\r\n    if (username) {\r\n      // If a username is provided, filter messages for that user (both public and private)\r\n      messages = await Message.find({\r\n        $or: [{ isPrivate: false }, { toUser: username }],\r\n      }).sort({ time: 1 });\r\n    } else {\r\n      // If no username is provided, return all messages (for admin or public view)\r\n      messages = await Message.find().sort({ time: 1 });\r\n    }\r\n\r\n    // Return the fetched messages in the response\r\n    res.json(messages);\r\n  } catch (error) {\r\n    // If an error occurs, log it and send the error response\r\n    console.log('Error fetching messages:', error);\r\n    res.status(500).send({ message: 'Error fetching messages', error });\r\n  }\r\n});\r\n\r\n// Serve static files (e.g., images, videos, etc.)\r\napp.use('/uploads', express.static(path.join(__dirname, 'uploads')));\r\n\r\n// Start the server\r\napp.listen(port, () => {\r\n  console.log(`Server running on port ${port}`);\r\n});\r\n\r\n"]}